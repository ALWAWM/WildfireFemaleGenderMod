import groovy.json.JsonOutput
import groovy.json.JsonSlurper

plugins {
    id('java')
    id('eclipse')
    id('idea')
    id('maven-publish')
    id('net.neoforged.gradle.userdev') version('7.0.136')//https://projects.neoforged.net/neoforged/neogradle
}

tasks.named('wrapper', Wrapper).configure {
    //Define wrapper values here so as to not have to always do so when updating gradlew.properties
    gradleVersion = '8.7'
    distributionType = Wrapper.DistributionType.ALL
}

project.base.archivesName = project.archives_base_name
version = "neoforge-${minecraft_version}-${mod_version}"
group = project.maven_group

ext {
    versionProperties = ['version': mod_version, 'mc_version': minecraft_version_range, 'neo_version': neo_version_range, 'loader_version': loader_version_range]
    jsonPatterns = ['**/*.json', '**/*.mcmeta']
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of("${java_version}"))
        vendor.set(JvmVendorSpec.JETBRAINS)
    }
}

println("Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}")

minecraft.accessTransformers.file(file('src/main/resources/META-INF/accesstransformer.cfg'))

runs {
    configureEach { net.neoforged.gradle.dsl.common.runs.run.Run run ->
        if (run.project.hasProperty('forge_force_ansi')) {
            //Force ansi if declared as a gradle variable, as the auto detection doesn't detect IntelliJ properly
            // or eclipse's plugin that adds support for ansi escape in console
            run.jvmArguments.add("-Dterminal.ansi=${run.project.property('forge_force_ansi')}")
        }

        run.modSources.add((SourceSet) sourceSets.main)

        //if the selected toolchain is a JBR, enable DCEVM
        if (run.project.javaToolchains.launcherFor(java.toolchain).map { it.metadata.vendor }.getOrElse('').contains('JetBrains')) {
            run.jvmArguments.add('-XX:+AllowEnhancedClassRedefinition')
        }
    }
    client {
        //The below if statements are to add args to your gradle.properties file in user home
        // (DO NOT add them directly to the gradle.properties file for this project)
        // Setting the below properties allows use of your normal Minecraft account in the
        // dev environment including having your skin load. Each property also has a comment
        // explaining what information to set the value to/format it expects
        // One thing to note is because of the caching that goes on, after changing these
        // variables, you need to refresh the project and rerun genIntellijRuns/genEclipseRuns
        if (project.hasProperty('mc_uuid')) {
            //Your uuid without any dashes in the middle
            programArguments.addAll('--uuid', (String) project.property('mc_uuid'))
        }
        if (project.hasProperty('mc_username')) {
            //Your username/display name, this is the name that shows up in chat
            // Note: This is not your email, even if you have a Mojang account
            programArguments.addAll('--username', (String) project.property('mc_username'))
        }
        if (project.hasProperty('mc_accessToken')) {
            //Your access token, you can find it in your '.minecraft/launcher_accounts.json' file
            programArguments.addAll('--accessToken', (String) project.property('mc_accessToken'))
        }
    }
    server {
    }
}

repositories {
}

dependencies {
    implementation("net.neoforged:neoforge:${neo_version}")
}

def replaceResources = tasks.register('replaceResources', Copy) {
    outputs.upToDateWhen { false }
    def modsToml = copySpec {
        from(sourceSets.main.resources) {
            include('META-INF/neoforge.mods.toml')
            expand(versionProperties)
        }
    }
    //Copy it into the build dir
    with(modsToml)
    into(layout.buildDirectory.dir('resources/main'))
    //If IntelliJ's output dir exists, copy it there as well
    if (new File("$rootDir/out/production/").exists()) {
        copy {
            with(modsToml)
            into("$rootDir/out/production/")
        }
    }
    //If Eclipse's output dir exists, copy it there as well
    if (new File("$rootDir/bin/main/").exists()) {
        copy {
            with(modsToml)
            into("$rootDir/bin/main/")
        }
    }
}

//Set the various variables/settings for the different process resources tasks
processResources {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    exclude('META-INF/mods.toml')
    configure { finalizedBy(replaceResources) }
    doLast {
        for (def file : fileTree(dir: getOutputs().getFiles().getAsPath(), includes: jsonPatterns)) {
            file.setText(JsonOutput.toJson(new JsonSlurper().parse(file)))
        }
    }
}

//Make the various classes tasks depend on the corresponding replaceResources tasks in addition to the default processResources tasks they depend on
classes.configure { dependsOn(replaceResources) }

// Example for how to get properties into the manifest for reading at runtime.
tasks.named('jar', Jar).configure {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    manifest.attributes([
            'Specification-Title'     : project.name,
            'Specification-Vendor'    : 'Wildfire',
            'Specification-Version'   : project.jar.archiveVersion,
            'Implementation-Title'    : project.name,
            'Implementation-Version'  : project.jar.archiveVersion,
            'Implementation-Vendor'   : 'Wildfire',
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            'Automatic-Module-Name'   : 'wildfire_gender'
    ])
}

publishing {
    publications { PublicationContainer publicationContainer ->
        publicationContainer.register('mavenJava', MavenPublication) { MavenPublication publication ->
            artifact(jar)
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/mcmodsrepo"
        }
    }
}

tasks.withType(JavaCompile).configureEach({
    options.encoding = 'UTF-8'
    options.compilerArgs.addAll(['-Xmaxerrs', '100000'])
})

tasks.withType(Javadoc).configureEach({
    options.tags = [
            'apiNote:a:<em>API Note:</em>',
            'implSpec:a:<em>Implementation Requirements:</em>',
            'implNote:a:<em>Implementation Note:</em>'
    ]
})