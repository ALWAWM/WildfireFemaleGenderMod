import groovy.json.JsonOutput
import groovy.json.JsonSlurper

plugins {
    id('java')
    id('eclipse')
    id('idea')
    id('maven-publish')
    id('net.neoforged.gradle.userdev') version('7.0.154')//https://projects.neoforged.net/neoforged/neogradle
}

tasks.named('wrapper', Wrapper).configure {
    //Define wrapper values here so as to not have to always do so when updating gradlew.properties
    gradleVersion = '8.9'
    distributionType = Wrapper.DistributionType.ALL
}

project.base.archivesName = project.archives_base_name
version = "neoforge-${minecraft_version}-${mod_version}"
group = project.maven_group

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of("${java_version}"))
        vendor.set(JvmVendorSpec.JETBRAINS)
    }
}

println("Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}")

minecraft.accessTransformers.file(file('src/main/resources/META-INF/accesstransformer.cfg'))

runs {
    configureEach {
        if (hasProperty('forge_force_ansi')) {
            //Force ansi if declared as a gradle variable, as the auto detection doesn't detect IntelliJ properly
            // or eclipse's plugin that adds support for ansi escape in console
            systemProperties.put('terminal.ansi', (String) property('forge_force_ansi'))
        }

        modSources.add((SourceSet) sourceSets.main)

        //if the selected toolchain is a JBR, enable DCEVM
        if (javaToolchains.launcherFor(java.toolchain).map { it.metadata.vendor }.getOrElse('').contains('JetBrains')) {
            jvmArguments.add('-XX:+AllowEnhancedClassRedefinition')
        }
    }
    //Note: To enable logging into the client account, set the neogradle.subsystems.devLogin.conventionForRun property to true in your gradle user home
    // https://github.com/neoforged/NeoGradle?tab=readme-ov-file#per-run-configuration
    client {
    }
    clientAlt {
        configure('client')
        //Force disable devLogin for clientAlt regardless of if it is enabled via gradle properties for the main gradle run
        devLogin.enabled(false)
        if (!(findProperty('neogradle.subsystems.devLogin.conventionForRun') ?: false)) {
            //If the property is missing or set to false (so the normal runClient task would use Dev as the name),
            // change the name of the alt client type so that it doesn't conflict with the main dev one
            programArguments.addAll((String[]) ['--username', 'AltDev'])
        }
    }
    server {
    }
}

repositories {
}

dependencies {
    implementation("net.neoforged:neoforge:${neo_version}")
}

def replaceResources = tasks.register('replaceResources', Copy) {
    def versionProperties = ['version': mod_version, 'mc_version': minecraft_version_range, 'neo_version': neo_version_range, 'loader_version': loader_version_range]
    inputs.properties(versionProperties)
    def modsToml = copySpec {
        from(sourceSets.main.resources) {
            include('META-INF/neoforge.mods.toml')
            expand(versionProperties)
        }
    }
    //Copy it into the build dir
    with(modsToml)
    into(layout.buildDirectory.dir('resources/main'))
    //If IntelliJ's output dir exists, copy it there as well
    if (new File("$rootDir/out/production/").exists()) {
        copy {
            with(modsToml)
            into("$rootDir/out/production/")
        }
    }
    //If Eclipse's output dir exists, copy it there as well
    if (new File("$rootDir/bin/main/").exists()) {
        copy {
            with(modsToml)
            into("$rootDir/bin/main/")
        }
    }
}

//Set the various variables/settings for the different process resources tasks
processResources {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    exclude('META-INF/mods.toml')
    configure { finalizedBy(replaceResources) }
    def files = fileTree(dir: outputs.files.asPath, includes: ['**/*.json', '**/*.mcmeta'])
    doLast {
        for (def file : files) {
            file.setText(JsonOutput.toJson(new JsonSlurper().parse(file)))
        }
    }
}

//Make the various classes tasks depend on the corresponding replaceResources tasks in addition to the default processResources tasks they depend on
classes.configure { dependsOn(replaceResources) }

// Example for how to get properties into the manifest for reading at runtime.
tasks.named('jar', Jar).configure {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    manifest.attributes([
            'Specification-Title'     : project.name,
            'Specification-Vendor'    : 'Wildfire',
            'Specification-Version'   : project.jar.archiveVersion,
            'Implementation-Title'    : project.name,
            'Implementation-Version'  : project.jar.archiveVersion,
            'Implementation-Vendor'   : 'Wildfire',
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            'Automatic-Module-Name'   : 'wildfire_gender'
    ])
}

publishing {
    publications { PublicationContainer publicationContainer ->
        publicationContainer.register('mavenJava', MavenPublication) { MavenPublication publication ->
            artifact(jar)
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/mcmodsrepo"
        }
    }
}

tasks.withType(JavaCompile).configureEach({
    options.encoding = 'UTF-8'
    options.compilerArgs.addAll(['-Xmaxerrs', '100000'])
})

tasks.withType(Javadoc).configureEach({
    options.encoding = 'UTF-8'
    options.tags = [
            'apiNote:a:<em>API Note:</em>',
            'implSpec:a:<em>Implementation Requirements:</em>',
            'implNote:a:<em>Implementation Note:</em>'
    ]
})